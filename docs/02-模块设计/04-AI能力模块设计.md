# 银龄守候·双模交互版 - AI能力模块设计

> 文档版本：v1.0  
> 更新日期：2025年12月21日  
> 文档状态：待完善

---

## 目录

- [1. AI能力概述](#1-ai能力概述)
- [2. 语音交互模块](#2-语音交互模块)
- [3. 图像识别模块](#3-图像识别模块)
- [4. 自然语言理解模块](#4-自然语言理解模块)
- [5. 虚拟形象引擎](#5-虚拟形象引擎)
- [6. 智能推荐引擎](#6-智能推荐引擎)
- [7. 第三方AI服务集成](#7-第三方ai服务集成)

---

## 1. AI能力概述

### 1.1 模块定位
AI能力模块是"银龄守候"的核心智能引擎，为老年端提供自然、智能的交互体验，主要包括：
- **语音交互**：实现"听"与"说"的能力
- **图像识别**：实现"看"与"认"的能力  
- **自然语言理解**：实现"懂"的能力
- **智能推荐**：实现"预测"的能力

### 1.2 AI能力全景图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           AI能力模块架构                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────┐    ┌────────────────┐    ┌────────────────┐       │
│  │  语音交互模块   │    │  图像识别模块   │    │  NLU理解模块   │       │
│  │                │    │                │    │                │       │
│  │  • ASR识别     │    │  • OCR识别     │    │  • 意图识别     │       │
│  │  • TTS合成     │    │  • 药品识别     │    │  • 槽位提取     │       │
│  │  • 音色定制    │    │  • 物体识别     │    │  • 上下文理解   │       │
│  └────────┬───────┘    └────────┬───────┘    └────────┬───────┘       │
│           │                     │                     │                │
│           └─────────────────────┼─────────────────────┘                │
│                                 │                                      │
│                          ┌──────▼──────┐                              │
│                          │  AI服务层    │                              │
│                          │ (统一调度)   │                              │
│                          └──────┬──────┘                              │
│                                 │                                      │
│           ┌─────────────────────┼─────────────────────┐                │
│           │                     │                     │                │
│           ▼                     ▼                     ▼                │
│  ┌────────────────┐    ┌────────────────┐    ┌────────────────┐       │
│  │  虚拟形象引擎   │    │  智能推荐引擎   │    │  对话管理引擎   │       │
│  │                │    │                │    │                │       │
│  │  • 动画生成    │    │  • 场景推荐     │    │  • 多轮对话     │       │
│  │  • 表情同步    │    │  • 时间推荐     │    │  • 状态管理     │       │
│  │  • 口型同步    │    │  • 行为分析     │    │  • 历史记录     │       │
│  └────────────────┘    └────────────────┘    └────────────────┘       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         第三方AI服务                                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 讯飞语音  │  │ 阿里OCR  │  │ 百度UNIT │  │ 通义千问  │  │ 视觉智能  │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 设计原则

| 原则 | 说明 | 实现方式 |
|:----|:----|:--------|
| **快速响应** | ASR首字<500ms，整体响应<2s | 流式处理、本地缓存 |
| **准确性优先** | 识别准确率>95% | 多模型融合、人工校正 |
| **降级策略** | 服务异常时优雅降级 | 本地模型、错误提示 |
| **成本可控** | AI调用成本在预算内 | 缓存策略、批量处理 |
| **隐私保护** | 语音图片不留存 | 流式处理、定期清理 |

### 1.4 技术选型对比

| AI能力 | 主选方案 | 优势 | 备选方案 | 成本预估 |
|:------|:--------|:----|:--------|:--------|
| ASR | 讯飞语音 | 方言支持好、实时性强 | 百度语音 | ¥0.02/次 |
| TTS | 讯飞语音 | 音色自然、支持情感 | 阿里云 | ¥0.01/次 |
| OCR | 阿里云 | 准确率高、定制化强 | 百度OCR | ¥0.03/次 |
| NLU | 百度UNIT | 易用性好、免费额度高 | Rasa | ¥0.01/次 |
| LLM | 通义千问 | 中文能力强、成本低 | 文心一言 | ¥0.008/千tokens |

### 1.5 性能指标

| 指标 | 目标值 | 说明 |
|:----|:------|:----|
| ASR识别准确率 | >95% | 普通话环境 |
| ASR首字延迟 | <500ms | 流式识别 |
| TTS合成速度 | >200字/秒 | 在线合成 |
| OCR识别准确率 | >98% | 印刷体药品说明书 |
| OCR响应时间 | <2s | 标准图片 |
| NLU意图准确率 | >90% | 核心意图 |
| 服务可用性 | >99.5% | 月度统计 |

## 2. 语音交互模块

### 2.1 模块架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      语音交互完整链路                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户说话                                                        │
│      │                                                          │
│      ▼                                                          │
│  ┌───────────┐                                                 │
│  │ 音频采集   │  AudioRecord (16kHz, 16bit, Mono)              │
│  │ 降噪处理   │  WebRTC AudioProcessing                        │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐                                                 │
│  │ VAD检测   │  Voice Activity Detection                       │
│  │ 静音检测   │  判断是否开始/结束说话                           │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 流式上传   │───────►│  讯飞ASR     │                         │
│  │ (WebSocket)│◄───────│  实时识别    │                         │
│  └───────────┘        └──────┬──────┘                         │
│                              │                                 │
│                              ▼                                 │
│                       识别文本输出                              │
│                              │                                 │
│                              ▼                                 │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 意图理解   │◄───────│  NLU服务     │                         │
│  │ 业务路由   │        │  意图+槽位   │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  执行业务逻辑                                                   │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 回复生成   │───────►│  讯飞TTS     │                         │
│  │ 文本组装   │        │  语音合成    │                         │
│  └───────────┘        └──────┬──────┘                         │
│                              │                                 │
│                              ▼                                 │
│  ┌───────────┐        合成语音数据                              │
│  │ 音频播放   │◄────────────┘                                  │
│  │ 形象同步   │  MediaPlayer + AvatarSync                      │
│  └───────────┘                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 ASR语音识别实现

#### 讯飞ASR集成

```kotlin
// ASR管理器
class AsrManager(private val context: Context) {
    
    private var speechRecognizer: SpeechRecognizer? = null
    private val recognitionListeners = mutableListOf<RecognitionListener>()
    
    fun initialize() {
        // 初始化讯飞SDK
        SpeechUtility.createUtility(context, "appid=${Constants.XUNFEI_APP_ID}")
        speechRecognizer = SpeechRecognizer.createRecognizer(context, null)
    }
    
    /**
     * 开始语音识别（流式）
     */
    fun startRecognition(isStream: Boolean = true) {
        speechRecognizer?.setParameter(SpeechConstant.DOMAIN, "iat")
        speechRecognizer?.setParameter(SpeechConstant.LANGUAGE, "zh_cn")
        speechRecognizer?.setParameter(SpeechConstant.ACCENT, "mandarin")
        
        // 启用流式识别
        if (isStream) {
            speechRecognizer?.setParameter(SpeechConstant.ASR_PTT, "0")
        }
        
        // 音频来源
        speechRecognizer?.setParameter(
            SpeechConstant.AUDIO_SOURCE,
            MediaRecorder.AudioSource.MIC.toString()
        )
        
        // 设置识别结果回调
        speechRecognizer?.startListening(object : RecognizerListener {
            override fun onVolumeChanged(volume: Int, data: ByteArray?) {
                // 音量变化，可用于虚拟形象动画
                notifyVolumeChanged(volume)
            }
            
            override fun onBeginOfSpeech() {
                Log.d(TAG, "开始说话")
                notifyBeginSpeech()
            }
            
            override fun onEndOfSpeech() {
                Log.d(TAG, "结束说话")
                notifyEndSpeech()
            }
            
            override fun onResult(results: RecognizerResult?, isLast: Boolean) {
                results?.let {
                    val text = parseResult(it)
                    notifyResult(text, isLast)
                }
            }
            
            override fun onError(error: SpeechError?) {
                Log.e(TAG, "识别错误: ${error?.errorDescription}")
                notifyError(error)
            }
        })
    }
    
    /**
     * 停止识别
     */
    fun stopRecognition() {
        speechRecognizer?.stopListening()
    }
    
    /**
     * 解析识别结果
     */
    private fun parseResult(result: RecognizerResult): String {
        val json = JSONObject(result.resultString)
        val ws = json.optJSONArray("ws") ?: return ""
        
        val builder = StringBuilder()
        for (i in 0 until ws.length()) {
            val cw = ws.optJSONObject(i).optJSONArray("cw")
            for (j in 0 until cw.length()) {
                val w = cw.optJSONObject(j).optString("w")
                builder.append(w)
            }
        }
        return builder.toString()
    }
    
    // 监听器管理
    fun addListener(listener: RecognitionListener) {
        recognitionListeners.add(listener)
    }
    
    private fun notifyResult(text: String, isLast: Boolean) {
        recognitionListeners.forEach { it.onRecognitionResult(text, isLast) }
    }
}

// 识别监听器接口
interface RecognitionListener {
    fun onRecognitionResult(text: String, isLast: Boolean)
    fun onVolumeChanged(volume: Int)
    fun onBeginSpeech()
    fun onEndSpeech()
    fun onError(error: SpeechError?)
}
```

### 2.3 TTS语音合成实现

```kotlin
// TTS管理器
class TtsManager(private val context: Context) {
    
    private var speechSynthesizer: SpeechSynthesizer? = null
    private val synthesisListeners = mutableListOf<SynthesisListener>()
    
    fun initialize() {
        speechSynthesizer = SpeechSynthesizer.createSynthesizer(context, null)
        configureTts()
    }
    
    private fun configureTts() {
        speechSynthesizer?.apply {
            // 设置发音人（可选多种音色）
            setParameter(SpeechConstant.VOICE_NAME, "xiaoyan")  // 温柔女声
            
            // 语速（0-100），默认50
            setParameter(SpeechConstant.SPEED, "45")  // 稍慢，便于老年人理解
            
            // 音量（0-100），默认50
            setParameter(SpeechConstant.VOLUME, "80")
            
            // 音调（0-100），默认50
            setParameter(SpeechConstant.PITCH, "50")
            
            // 音频采样率
            setParameter(SpeechConstant.SAMPLE_RATE, "16000")
        }
    }
    
    /**
     * 合成并播放语音
     */
    fun speak(text: String, onComplete: (() -> Unit)? = null) {
        speechSynthesizer?.startSpeaking(text, object : SynthesizerListener {
            override fun onSpeakBegin() {
                Log.d(TAG, "开始播放")
                notifySpeakBegin()
            }
            
            override fun onBufferProgress(
                percent: Int,
                beginPos: Int,
                endPos: Int,
                info: String?
            ) {
                Log.d(TAG, "缓冲进度: $percent%")
            }
            
            override fun onSpeakPaused() {}
            
            override fun onSpeakResumed() {}
            
            override fun onSpeakProgress(
                percent: Int,
                beginPos: Int,
                endPos: Int
            ) {
                // 播放进度，用于口型同步
                notifySpeakProgress(percent, text.substring(beginPos, endPos))
            }
            
            override fun onCompleted(error: SpeechError?) {
                if (error == null) {
                    Log.d(TAG, "播放完成")
                    onComplete?.invoke()
                    notifySpeakComplete()
                } else {
                    Log.e(TAG, "播放错误: ${error.errorDescription}")
                    notifyError(error)
                }
            }
            
            override fun onEvent(eventType: Int, arg1: Int, arg2: Int, obj: Bundle?) {}
        })
    }
    
    /**
     * 停止播放
     */
    fun stop() {
        speechSynthesizer?.stopSpeaking()
    }
    
    /**
     * 暂停播放
     */
    fun pause() {
        speechSynthesizer?.pauseSpeaking()
    }
    
    /**
     * 恢复播放
     */
    fun resume() {
        speechSynthesizer?.resumeSpeaking()
    }
    
    /**
     * 设置音色
     */
    fun setVoice(voiceName: String) {
        speechSynthesizer?.setParameter(SpeechConstant.VOICE_NAME, voiceName)
    }
    
    private fun notifySpeakBegin() {
        synthesisListeners.forEach { it.onSpeakBegin() }
    }
    
    private fun notifySpeakProgress(percent: Int, currentText: String) {
        synthesisListeners.forEach { it.onSpeakProgress(percent, currentText) }
    }
    
    private fun notifySpeakComplete() {
        synthesisListeners.forEach { it.onSpeakComplete() }
    }
}

// 合成监听器接口
interface SynthesisListener {
    fun onSpeakBegin()
    fun onSpeakProgress(percent: Int, currentText: String)
    fun onSpeakComplete()
    fun onError(error: SpeechError?)
}
```

### 2.4 音色定制

| 音色名称 | voiceName | 特点 | 适用场景 |
|:--------|:----------|:----|:--------|
| 小燕（温柔女声） | xiaoyan | 温柔亲切 | **默认推荐** |
| 许久（温暖男声） | xiaoyu | 沉稳可靠 | 男性老人偏好 |
| 许小宝（童声） | aisbabyxu | 活泼可爱 | 趣味场景 |
| 子女声音（定制） | custom | 子女录音训练 | **付费功能** |

### 2.5 降噪与优化

```kotlin
// 音频预处理
class AudioPreprocessor {
    
    private val webRtcNs: WebRtcNs by lazy {
        WebRtcNs()
    }
    
    /**
     * 降噪处理
     */
    fun denoise(audioData: ByteArray): ByteArray {
        webRtcNs.init(16000)  // 采样率16kHz
        webRtcNs.nsProcess(audioData)
        return audioData
    }
    
    /**
     * 音量归一化
     */
    fun normalize(audioData: ByteArray): ByteArray {
        val samples = audioData.toShortArray()
        val maxSample = samples.maxOrNull()?.toFloat() ?: 1f
        val scale = Short.MAX_VALUE / maxSample
        
        samples.forEachIndexed { index, sample ->
            samples[index] = (sample * scale).toInt().toShort()
        }
        
        return samples.toByteArray()
    }
}
```

### 2.6 语音缓存策略

| 缓存类型 | 缓存内容 | 过期策略 | 目的 |
|:--------|:--------|:--------|:----|
| 常用语缓存 | 高频回复语音文件 | 30天 | 加快响应 |
| 提醒语缓存 | 用药提醒等固定语音 | 永久 | 离线可用 |
| TTS结果缓存 | 相同文本的合成结果 | 7天 | 节省成本 |

## 3. 图像识别模块

### 3.1 识别类型

| 识别类型 | 应用场景 | 技术方案 | 准确率要求 |
|:--------|:--------|:--------|:----------|
| **药品识别** | 识别药盒上的药品信息 | OCR + 药品库匹配 | >98% |
| **文字识别** | 阅读任何文字材料 | 通用OCR | >95% |
| **物体识别** | 识别日常物品（扩展） | 图像分类 | >90% |

### 3.2 药品识别完整流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      药品识别完整流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户拍照                                                        │
│      │                                                          │
│      ▼                                                          │
│  ┌───────────┐                                                 │
│  │ 图片采集   │  CameraX拍摄                                    │
│  │ 质量检测   │  检查清晰度、亮度                                │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐                                                 │
│  │ 图片预处理  │  压缩、旋转、裁剪                                │
│  │ 尺寸优化   │  限制在2MB以内                                  │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 上传OSS    │───────►│  阿里云OSS   │                         │
│  │ 获取URL    │◄───────│  对象存储    │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 调用OCR    │───────►│  阿里云OCR   │                         │
│  │ 文字识别   │◄───────│  药品专用    │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 信息提取   │───────►│  药品数据库   │                         │
│  │ 结构化解析 │◄───────│  匹配查询    │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐                                                 │
│  │ 结果组装   │  药品名称、用法用量、注意事项                     │
│  │ 语音播报   │  TTS朗读 + 卡片展示                             │
│  └───────────┘                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 图像预处理实现

```kotlin
// 图片处理工具
class ImageProcessor(private val context: Context) {
    
    /**
     * 压缩图片
     * @param maxSize 最大文件大小（字节）
     */
    fun compressImage(bitmap: Bitmap, maxSize: Long = 2 * 1024 * 1024): ByteArray {
        val outputStream = ByteArrayOutputStream()
        var quality = 90
        
        // 逐步降低质量直到满足大小要求
        do {
            outputStream.reset()
            bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream)
            quality -= 10
        } while (outputStream.size() > maxSize && quality > 0)
        
        return outputStream.toByteArray()
    }
    
    /**
     * 旋转图片（修正方向）
     */
    fun rotateImage(bitmap: Bitmap, imageUri: Uri): Bitmap {
        val exif = ExifInterface(context.contentResolver.openInputStream(imageUri)!!)
        val orientation = exif.getAttributeInt(
            ExifInterface.TAG_ORIENTATION,
            ExifInterface.ORIENTATION_NORMAL
        )
        
        val matrix = Matrix()
        when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
            ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
            ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
        }
        
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
    }
    
    /**
     * 图片质量检测
     */
    fun checkQuality(bitmap: Bitmap): QualityCheckResult {
        val blurScore = calculateBlurScore(bitmap)
        val brightnessScore = calculateBrightness(bitmap)
        
        return QualityCheckResult(
            isBlur = blurScore < 100,
            isTooDark = brightnessScore < 50,
            isTooLight = brightnessScore > 200,
            overallQuality = if (blurScore >= 100 && brightnessScore in 50..200) {
                QualityLevel.GOOD
            } else {
                QualityLevel.POOR
            }
        )
    }
    
    /**
     * 计算模糊度（拉普拉斯算子）
     */
    private fun calculateBlurScore(bitmap: Bitmap): Double {
        val mat = Mat()
        Utils.bitmapToMat(bitmap, mat)
        
        val gray = Mat()
        Imgproc.cvtColor(mat, gray, Imgproc.COLOR_RGB2GRAY)
        
        val laplacian = Mat()
        Imgproc.Laplacian(gray, laplacian, CvType.CV_64F)
        
        val mu = MatOfDouble()
        val sigma = MatOfDouble()
        Core.meanStdDev(laplacian, mu, sigma)
        
        return sigma.get(0, 0)[0] * sigma.get(0, 0)[0]
    }
    
    /**
     * 计算亮度
     */
    private fun calculateBrightness(bitmap: Bitmap): Double {
        var totalBrightness = 0.0
        val pixels = IntArray(bitmap.width * bitmap.height)
        bitmap.getPixels(pixels, 0, bitmap.width, 0, 0, bitmap.width, bitmap.height)
        
        pixels.forEach { pixel ->
            val r = Color.red(pixel)
            val g = Color.green(pixel)
            val b = Color.blue(pixel)
            totalBrightness += (0.299 * r + 0.587 * g + 0.114 * b)
        }
        
        return totalBrightness / pixels.size
    }
}

data class QualityCheckResult(
    val isBlur: Boolean,
    val isTooDark: Boolean,
    val isTooLight: Boolean,
    val overallQuality: QualityLevel
)

enum class QualityLevel {
    GOOD, POOR
}
```

### 3.4 OCR服务调用

```kotlin
// OCR服务封装
class OcrService(
    private val apiClient: ApiClient,
    private val cacheService: CacheService
) {
    
    /**
     * 识别药品
     */
    suspend fun recognizeMedicine(imageUrl: String): MedicineInfo {
        // 1. 检查缓存（相同图片可能被重复识别）
        val cacheKey = "ocr:medicine:${imageUrl.hashCode()}"
        cacheService.get<MedicineInfo>(cacheKey)?.let {
            return it
        }
        
        // 2. 调用阿里云OCR
        val ocrResult = callAliyunOcr(imageUrl)
        
        // 3. 解析OCR结果，提取关键信息
        val medicineInfo = parseMedicineInfo(ocrResult)
        
        // 4. 缓存结果（24小时）
        cacheService.set(cacheKey, medicineInfo, Duration.ofHours(24))
        
        return medicineInfo
    }
    
    /**
     * 调用阿里云OCR API
     */
    private suspend fun callAliyunOcr(imageUrl: String): OcrResult {
        val request = OcrRequest(
            imageUrl = imageUrl,
            type = "medicine"  // 药品专用识别
        )
        
        return apiClient.post("/ai/ocr/recognize", request)
    }
    
    /**
     * 解析药品信息
     */
    private fun parseMedicineInfo(ocrResult: OcrResult): MedicineInfo {
        val text = ocrResult.text
        
        // 使用正则表达式提取关键信息
        val namePattern = "【药品名称】(.+?)【".toRegex()
        val dosagePattern = "【规格】(.+?)【".toRegex()
        val usagePattern = "【用法用量】(.+?)【".toRegex()
        val precautionsPattern = "【注意事项】(.+?)【".toRegex()
        
        return MedicineInfo(
            name = namePattern.find(text)?.groupValues?.get(1)?.trim() ?: "未识别",
            genericName = extractGenericName(text),
            dosage = dosagePattern.find(text)?.groupValues?.get(1)?.trim(),
            usage = usagePattern.find(text)?.groupValues?.get(1)?.trim() ?: "请遵医嘱",
            frequency = extractFrequency(text),
            precautions = extractPrecautions(text),
            imageUrl = ocrResult.imageUrl,
            confidence = ocrResult.confidence
        )
    }
    
    /**
     * 提取通用名
     */
    private fun extractGenericName(text: String): String? {
        val pattern = "通用名称?[：:](.*?)[\n\r]".toRegex()
        return pattern.find(text)?.groupValues?.get(1)?.trim()
    }
    
    /**
     * 提取用药频次
     */
    private fun extractFrequency(text: String): String? {
        val patterns = listOf(
            "每日(\\d+)次".toRegex(),
            "一日(\\d+)次".toRegex(),
            "(\\d+)次/日".toRegex()
        )
        
        patterns.forEach { pattern ->
            pattern.find(text)?.let { match ->
                val times = match.groupValues[1]
                return "每日${times}次"
            }
        }
        
        return null
    }
    
    /**
     * 提取注意事项
     */
    private fun extractPrecautions(text: String): List<String> {
        val precautionSection = text.substringAfter("【注意事项】", "")
            .substringBefore("【", "")
        
        return precautionSection.split("\\d+[.、]".toRegex())
            .map { it.trim() }
            .filter { it.isNotEmpty() }
    }
}

// 药品信息数据模型
data class MedicineInfo(
    val name: String,              // 商品名
    val genericName: String?,      // 通用名
    val dosage: String?,           // 规格
    val usage: String,             // 用法
    val frequency: String?,        // 用量频次
    val precautions: List<String>, // 注意事项
    val imageUrl: String,          // 原图URL
    val confidence: Float          // 识别置信度
)
```

### 3.5 后端OCR服务

```java
@Service
public class OcrService {
    
    @Value("${aliyun.ocr.appcode}")
    private String appCode;
    
    private static final String OCR_URL = "https://ocrapi-advanced.taobao.com/ocrservice/advanced";
    
    /**
     * 调用阿里云OCR识别
     */
    public OcrResult recognize(String imageUrl) {
        try {
            // 构建请求
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(OCR_URL))
                .header("Authorization", "APPCODE " + appCode)
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(
                    new JSONObject()
                        .put("image", imageUrl)
                        .put("configure", new JSONObject()
                            .put("min_size", 10)
                            .put("output_prob", true)
                        )
                        .toString()
                ))
                .build();
            
            // 发送请求
            HttpResponse<String> response = HttpClient.newHttpClient()
                .send(request, HttpResponse.BodyHandlers.ofString());
            
            // 解析响应
            JSONObject json = new JSONObject(response.body());
            
            return OcrResult.builder()
                .text(extractText(json))
                .confidence(extractConfidence(json))
                .imageUrl(imageUrl)
                .build();
                
        } catch (Exception e) {
            log.error("OCR识别失败", e);
            throw new BusinessException("图片识别失败，请重试");
        }
    }
    
    private String extractText(JSONObject json) {
        JSONArray words = json.optJSONArray("words");
        if (words == null) return "";
        
        StringBuilder text = new StringBuilder();
        for (int i = 0; i < words.length(); i++) {
            JSONObject word = words.optJSONObject(i);
            text.append(word.optString("word")).append("\n");
        }
        
        return text.toString();
    }
    
    private float extractConfidence(JSONObject json) {
        JSONArray probs = json.optJSONArray("probs");
        if (probs == null || probs.length() == 0) return 0.0f;
        
        float sum = 0;
        for (int i = 0; i < probs.length(); i++) {
            sum += probs.optDouble(i);
        }
        
        return (float) (sum / probs.length());
    }
}
```

### 3.6 图片缓存与清理策略

| 缓存类型 | 存储位置 | 清理策略 | 大小限制 |
|:--------|:--------|:--------|:--------|
| 原始图片 | 本地临时目录 | 识别完成后立即删除 | 单张<5MB |
| 压缩图片 | OSS对象存储 | 7天后自动删除 | 单张<2MB |
| OCR结果 | Redis缓存 | 24小时过期 | - |
| 识别记录 | MySQL数据库 | 30天后归档 | - |

## 4. 自然语言理解模块

### 4.1 NLU架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                     NLU处理流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户语音文本                                                    │
│      │                                                          │
│      ▼                                                          │
│  ┌───────────┐                                                 │
│  │ 文本预处理  │  分词、去停用词、纠错                             │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 意图识别   │───────►│  百度UNIT    │                         │
│  │ (Intent)  │◄───────│  意图分类    │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐        ┌─────────────┐                         │
│  │ 槽位提取   │───────►│  实体识别    │                         │
│  │ (Slot)    │◄───────│  关键信息    │                         │
│  └─────┬─────┘        └─────────────┘                         │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐                                                 │
│  │ 上下文管理  │  多轮对话状态维护                                │
│  └─────┬─────┘                                                 │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────┐                                                 │
│  │ 业务路由   │  根据意图调用对应服务                             │
│  └───────────┘                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 意图定义与训练

#### 意图分类体系

| 意图类别 | 意图ID | 示例语句 | 置信度阈值 |
|:--------|:------|:--------|:----------|
| **健康管理** | | | |
| 查看药品 | `medicine_check` | "这个药怎么吃"、"帮我看看这个药" | 0.7 |
| 设置提醒 | `set_reminder` | "提醒我吃药"、"下午三点提醒我" | 0.75 |
| **通讯互动** | | | |
| 打电话 | `make_call` | "给儿子打电话"、"我要打电话" | 0.8 |
| 听留言 | `play_message` | "有没有留言"、"听听消息" | 0.75 |
| **文字阅读** | | | |
| 读文字 | `read_text` | "读一下这个"、"这上面写的啥" | 0.7 |
| **闲聊** | | | |
| 问候 | `greet` | "你好"、"在吗" | 0.6 |
| 闲聊 | `chat` | "今天天气怎么样"、"陪我聊聊" | 0.5 |
| **帮助** | | | |
| 求助 | `help` | "你能帮我做什么"、"怎么用" | 0.7 |

#### 槽位定义

```json
{
  "make_call": {
    "slots": [
      {
        "name": "contact_name",
        "type": "string",
        "required": true,
        "prompt": "您要给谁打电话？"
      },
      {
        "name": "contact_relation",
        "type": "enum",
        "values": ["儿子", "女儿", "老伴", "医生"],
        "required": false
      }
    ]
  },
  "set_reminder": {
    "slots": [
      {
        "name": "reminder_type",
        "type": "enum",
        "values": ["吃药", "喝水", "运动", "测血压"],
        "required": true
      },
      {
        "name": "reminder_time",
        "type": "datetime",
        "required": true,
        "prompt": "什么时候提醒您？"
      }
    ]
  }
}
```

### 4.3 NLU服务实现

```kotlin
// NLU管理器
class NluManager(
    private val unitService: BaiduUnitService,
    private val contextManager: DialogContextManager
) {
    
    /**
     * 理解用户输入
     */
    suspend fun understand(text: String, userId: Long): NluResult {
        // 1. 预处理
        val processedText = preprocessText(text)
        
        // 2. 调用百度UNIT
        val unitResult = unitService.query(processedText, userId)
        
        // 3. 提取意图和槽位
        val intent = unitResult.intent
        val slots = unitResult.slots
        val confidence = unitResult.confidence
        
        // 4. 检查是否需要槽位填充
        val missingSlots = checkMissingSlots(intent, slots)
        
        // 5. 更新上下文
        contextManager.updateContext(userId, intent, slots)
        
        return NluResult(
            intent = intent,
            slots = slots,
            confidence = confidence,
            needsSlotFilling = missingSlots.isNotEmpty(),
            missingSlots = missingSlots,
            response = generateResponse(intent, slots, missingSlots)
        )
    }
    
    /**
     * 文本预处理
     */
    private fun preprocessText(text: String): String {
        return text
            .trim()
            .replace("\\s+".toRegex(), " ")  // 多空格转单空格
            .replace("[,，。.!！?？;；]".toRegex(), "")  // 去标点
    }
    
    /**
     * 检查缺失槽位
     */
    private fun checkMissingSlots(
        intent: String,
        slots: Map<String, Any>
    ): List<SlotDefinition> {
        val requiredSlots = IntentConfig.getRequiredSlots(intent)
        return requiredSlots.filter { !slots.containsKey(it.name) }
    }
    
    /**
     * 生成回复
     */
    private fun generateResponse(
        intent: String,
        slots: Map<String, Any>,
        missingSlots: List<SlotDefinition>
    ): String {
        return when {
            missingSlots.isNotEmpty() -> {
                // 需要询问缺失槽位
                missingSlots.first().prompt
            }
            else -> {
                // 意图确认
                IntentConfig.getConfirmTemplate(intent, slots)
            }
        }
    }
}

// NLU结果
data class NluResult(
    val intent: String,
    val slots: Map<String, Any>,
    val confidence: Float,
    val needsSlotFilling: Boolean,
    val missingSlots: List<SlotDefinition>,
    val response: String
)
```

### 4.4 对话上下文管理

```kotlin
// 对话上下文管理器
class DialogContextManager(private val redis: RedisTemplate<String, Any>) {
    
    private val contextExpire = Duration.ofMinutes(5)
    
    /**
     * 获取对话上下文
     */
    fun getContext(userId: Long): DialogContext? {
        val key = "dialog:context:$userId"
        return redis.opsForValue().get(key) as? DialogContext
    }
    
    /**
     * 更新对话上下文
     */
    fun updateContext(
        userId: Long,
        intent: String,
        slots: Map<String, Any>
    ) {
        val key = "dialog:context:$userId"
        val context = getContext(userId) ?: DialogContext(userId)
        
        context.apply {
            lastIntent = intent
            currentSlots.putAll(slots)
            turnCount++
            lastUpdateTime = LocalDateTime.now()
        }
        
        redis.opsForValue().set(key, context, contextExpire)
    }
    
    /**
     * 清除上下文
     */
    fun clearContext(userId: Long) {
        val key = "dialog:context:$userId"
        redis.delete(key)
    }
}

// 对话上下文
data class DialogContext(
    val userId: Long,
    var lastIntent: String = "",
    val currentSlots: MutableMap<String, Any> = mutableMapOf(),
    var turnCount: Int = 0,
    var lastUpdateTime: LocalDateTime = LocalDateTime.now()
)
```

### 4.5 意图路由

```kotlin
// 意图路由器
class IntentRouter(
    private val medicineService: MedicineService,
    private val callService: CallService,
    private val messageService: MessageService,
    private val reminderService: ReminderService
) {
    
    /**
     * 路由到对应服务
     */
    suspend fun route(nluResult: NluResult, userId: Long): ActionResult {
        return when (nluResult.intent) {
            "medicine_check" -> {
                // 打开相机识别药品
                ActionResult.openCamera(CameraMode.MEDICINE)
            }
            
            "make_call" -> {
                val contactName = nluResult.slots["contact_name"] as? String
                if (contactName != null) {
                    // 拨打电话
                    val contact = callService.findContact(userId, contactName)
                    ActionResult.makeCall(contact)
                } else {
                    // 显示联系人列表
                    ActionResult.showContactList()
                }
            }
            
            "play_message" -> {
                // 播放最新留言
                val messages = messageService.getUnreadMessages(userId)
                ActionResult.playMessages(messages)
            }
            
            "set_reminder" -> {
                val type = nluResult.slots["reminder_type"] as? String
                val time = nluResult.slots["reminder_time"] as? LocalDateTime
                
                if (type != null && time != null) {
                    // 创建提醒
                    reminderService.createReminder(userId, type, time)
                    ActionResult.success("好的，我会在${time.format()}提醒您$type")
                } else {
                    ActionResult.needMoreInfo(nluResult.response)
                }
            }
            
            "read_text" -> {
                // 打开相机识别文字
                ActionResult.openCamera(CameraMode.TEXT)
            }
            
            "chat" -> {
                // 调用LLM闲聊
                val response = generateChatResponse(nluResult.slots["text"] as String)
                ActionResult.chat(response)
            }
            
            "help" -> {
                ActionResult.showHelp()
            }
            
            else -> {
                ActionResult.unknown("抱歉，我没听明白，您可以说得再具体一些吗？")
            }
        }
    }
}

// 行动结果
sealed class ActionResult {
    data class OpenCamera(val mode: CameraMode) : ActionResult()
    data class MakeCall(val contact: Contact) : ActionResult()
    data class PlayMessages(val messages: List<VoiceMessage>) : ActionResult()
    data class Success(val message: String) : ActionResult()
    data class NeedMoreInfo(val prompt: String) : ActionResult()
    data class Chat(val response: String) : ActionResult()
    object ShowHelp : ActionResult()
    data class Unknown(val message: String) : ActionResult()
    
    companion object {
        fun openCamera(mode: CameraMode) = OpenCamera(mode)
        fun makeCall(contact: Contact) = MakeCall(contact)
        fun playMessages(messages: List<VoiceMessage>) = PlayMessages(messages)
        fun success(message: String) = Success(message)
        fun needMoreInfo(prompt: String) = NeedMoreInfo(prompt)
        fun chat(response: String) = Chat(response)
        fun showHelp() = ShowHelp
        fun unknown(message: String) = Unknown(message)
    }
}
```

## 5. 虚拟形象引擎

### 5.1 形象设计

#### 形象类型

| 类型 | 说明 | 实现方式 | 适用场景 |
|:----|:----|:--------|:--------|
| 默认形象 | 可爱卡通虚拟助手 | Lottie动画 | 标准用户 |
| 照片形象 | 基于子女照片生成 | AI人脸生成 | 高级用户 |
| 定制形象 | 多种风格可选 | 多套Lottie | 付费用户 |

#### 动画状态机

```
┌─────────────────────────────────────────────────────────────┐
│                   虚拟形象状态机                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                   ┌─────────┐                               │
│              ┌───►│  Idle   │◄────┐                         │
│              │    │  待机    │     │                         │
│              │    └────┬────┘     │                         │
│              │         │          │                         │
│              │         ▼          │                         │
│         超时  │    ┌─────────┐    │ 说话结束                  │
│              │    │Listening│    │                         │
│              │    │  听取    │    │                         │
│              │    └────┬────┘    │                         │
│              │         │         │                         │
│              │         ▼         │                         │
│              │    ┌─────────┐   │                         │
│              │    │Thinking │   │                         │
│              │    │  思考    │   │                         │
│              │    └────┬────┘   │                         │
│              │         │         │                         │
│              │         ▼         │                         │
│              └────┌─────────┐───┘                         │
│                   │Speaking │                             │
│                   │  说话    │                             │
│                   └─────────┘                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Lottie动画实现

```kotlin
// 虚拟形象动画控制器
class AvatarAnimator(
    private val lottieView: LottieAnimationView,
    private val ttsManager: TtsManager
) {
    
    private var currentState = AvatarState.IDLE
    private val stateAnimations = mapOf(
        AvatarState.IDLE to "avatar_idle.json",
        AvatarState.LISTENING to "avatar_listening.json",
        AvatarState.THINKING to "avatar_thinking.json",
        AvatarState.SPEAKING to "avatar_speaking.json",
        AvatarState.HAPPY to "avatar_happy.json"
    )
    
    init {
        setupAnimations()
    }
    
    private fun setupAnimations() {
        // 预加载所有动画
        stateAnimations.forEach { (_, animFile) ->
            lottieView.context.assets.open("lottie/$animFile").use { stream ->
                LottieComposition.Factory.fromInputStream(stream, null)
            }
        }
    }
    
    /**
     * 切换状态
     */
    fun setState(newState: AvatarState) {
        if (currentState == newState) return
        
        currentState = newState
        val animFile = stateAnimations[newState] ?: return
        
        lottieView.apply {
            setAnimation(animFile)
            
            when (newState) {
                AvatarState.IDLE -> {
                    repeatCount = LottieDrawable.INFINITE
                    speed = 0.5f
                }
                AvatarState.LISTENING -> {
                    repeatCount = LottieDrawable.INFINITE
                    speed = 1.0f
                }
                AvatarState.THINKING -> {
                    repeatCount = 3
                    speed = 0.8f
                }
                AvatarState.SPEAKING -> {
                    repeatCount = LottieDrawable.INFINITE
                    speed = 1.0f
                }
                AvatarState.HAPPY -> {
                    repeatCount = 2
                    speed = 1.0f
                }
            }
            
            playAnimation()
        }
    }
    
    /**
     * 同步口型动画
     */
    fun syncWithTts(text: String) {
        setState(AvatarState.SPEAKING)
        
        // 监听TTS播放进度
        ttsManager.addListener(object : SynthesisListener {
            override fun onSpeakProgress(percent: Int, currentText: String) {
                // 根据音量调整动画速度
                adjustAnimationSpeed(percent)
            }
            
            override fun onSpeakComplete() {
                setState(AvatarState.IDLE)
            }
        })
    }
    
    /**
     * 根据音量调整动画
     */
    fun adjustAnimationByVolume(volume: Int) {
        when (currentState) {
            AvatarState.LISTENING -> {
                // 音量越大，动画越快
                val speed = 0.5f + (volume / 100f) * 1.5f
                lottieView.speed = speed.coerceIn(0.5f, 2.0f)
            }
            AvatarState.SPEAKING -> {
                // 根据TTS音量调整口型开合幅度
                val scale = 0.8f + (volume / 100f) * 0.4f
                lottieView.scaleX = scale
                lottieView.scaleY = scale
            }
            else -> {}
        }
    }
    
    private fun adjustAnimationSpeed(ttsPercent: Int) {
        // 可根据TTS播放进度微调动画
        val speed = when {
            ttsPercent < 30 -> 0.8f
            ttsPercent < 70 -> 1.0f
            else -> 1.2f
        }
        lottieView.speed = speed
    }
}

enum class AvatarState {
    IDLE,      // 待机
    LISTENING, // 听取
    THINKING,  // 思考
    SPEAKING,  // 说话
    HAPPY      // 开心
}
```

### 5.3 子女照片生成形象

```kotlin
// AI形象生成服务
class AvatarGenerationService(
    private val apiClient: ApiClient
) {
    
    /**
     * 根据照片生成虚拟形象
     */
    suspend fun generateAvatar(photoUrl: String): GeneratedAvatar {
        // 调用阿里云视觉智能API
        val request = AvatarGenerationRequest(
            imageUrl = photoUrl,
            style = "cartoon",  // 卡通风格
            gender = "auto"     // 自动识别
        )
        
        val response: AvatarGenerationResponse = apiClient.post(
            "/ai/avatar/generate",
            request
        )
        
        return GeneratedAvatar(
            avatarUrl = response.avatarUrl,
            animationData = response.animationData,
            previewUrl = response.previewUrl
        )
    }
    
    /**
     * 声音克隆（付费功能）
     */
    suspend fun cloneVoice(audioSamples: List<String>): ClonedVoice {
        // 需要子女录制5-10段语音样本
        val request = VoiceCloneRequest(
            audioUrls = audioSamples,
            speakerName = "custom"
        )
        
        val response: VoiceCloneResponse = apiClient.post(
            "/ai/voice/clone",
            request
        )
        
        return ClonedVoice(
            voiceId = response.voiceId,
            previewUrl = response.previewUrl
        )
    }
}
```

### 5.4 形象配置管理

```kotlin
// 形象配置
data class AvatarConfig(
    val type: AvatarType,
    val lottieFile: String?,
    val customAvatarUrl: String?,
    val voiceId: String = "xiaoyan"
)

enum class AvatarType {
    DEFAULT,   // 默认形象
    PHOTO,     // 照片生成
    CUSTOM     // 定制形象
}

// 用户形象设置
class AvatarSettings(private val dataStore: DataStore<Preferences>) {
    
    companion object {
        val AVATAR_TYPE = stringPreferencesKey("avatar_type")
        val AVATAR_URL = stringPreferencesKey("avatar_url")
        val VOICE_ID = stringPreferencesKey("voice_id")
    }
    
    fun getAvatarConfig(): Flow<AvatarConfig> = dataStore.data.map { prefs ->
        AvatarConfig(
            type = AvatarType.valueOf(
                prefs[AVATAR_TYPE] ?: AvatarType.DEFAULT.name
            ),
            lottieFile = when (prefs[AVATAR_TYPE]) {
                AvatarType.DEFAULT.name -> "avatar_default.json"
                else -> null
            },
            customAvatarUrl = prefs[AVATAR_URL],
            voiceId = prefs[VOICE_ID] ?: "xiaoyan"
        )
    }
    
    suspend fun setAvatarConfig(config: AvatarConfig) {
        dataStore.edit { prefs ->
            prefs[AVATAR_TYPE] = config.type.name
            config.customAvatarUrl?.let { prefs[AVATAR_URL] = it }
            prefs[VOICE_ID] = config.voiceId
        }
    }
}
```

## 6. 智能推荐引擎

### 6.1 推荐策略

#### 推荐场景

| 场景 | 触发条件 | 推荐内容 | 优先级 |
|:----|:--------|:---------|:------|
| **健康管理** | | | |
| 吃药提醒 | 距离设定时间10分钟 | "该吃药了，别忘了哦" | 高 |
| 饮水提醒 | 超过2小时未与系统交互 | "要多喝水哦" | 中 |
| 运动建议 | 上午3-10点 | "天气不错，出去走走吧" | 中 |
| **情感关怀** | | | |
| 子女关注 | 子女留言/查看健康数据 | "您的孩子很关心您" | 高 |
| 互动建议 | 超过24小时无子女交互 | "给孩子打个电话吧" | 中 |
| **安全防护** | | | |
| 诈骗警告 | 检测到风险电话 | "这可能是诈骗电话" | 极高 |
| 健康提示 | 检测异常药品 | "请咨询医生" | 高 |

### 6.2 推荐算法

```kotlin
// 推荐引擎
class RecommendationEngine(
    private val userBehaviorService: UserBehaviorService,
    private val healthDataService: HealthDataService,
    private val weatherService: WeatherService
) {
    
    /**
     * 生成个性化推荐
     */
    suspend fun generateRecommendations(userId: Long): List<Recommendation> {
        val recommendations = mutableListOf<Recommendation>()
        
        // 1. 药品提醒推荐
        val medicineReminders = checkMedicineReminders(userId)
        recommendations.addAll(medicineReminders)
        
        // 2. 健康活动推荐
        val activitySuggestions = suggestActivities(userId)
        recommendations.addAll(activitySuggestions)
        
        // 3. 社交互动推荐
        val socialSuggestions = suggestSocialInteractions(userId)
        recommendations.addAll(socialSuggestions)
        
        // 4. 安全警告
        val securityAlerts = checkSecurityAlerts(userId)
        recommendations.addAll(securityAlerts)
        
        // 按优先级排序
        return recommendations.sortedByDescending { it.priority }
    }
    
    /**
     * 检查药品提醒
     */
    private suspend fun checkMedicineReminders(userId: Long): List<Recommendation> {
        val reminders = healthDataService.getUpcomingReminders(userId)
        val now = LocalDateTime.now()
        
        return reminders
            .filter { it.reminderTime.minusMinutes(10) <= now }
            .filter { it.reminderTime > now }
            .map { reminder ->
                Recommendation(
                    type = RecommendationType.MEDICINE,
                    title = "吃药提醒",
                    content = "请记得服用${reminder.medicineName}",
                    priority = Priority.HIGH,
                    action = RecommendationAction.OpenMedicine(reminder.id)
                )
            }
    }
    
    /**
     * 推荐活动
     */
    private suspend fun suggestActivities(userId: Long): List<Recommendation> {
        val recommendations = mutableListOf<Recommendation>()
        val now = LocalDateTime.now()
        val hour = now.hour
        
        // 饮水提醒
        val lastInteraction = userBehaviorService.getLastInteractionTime(userId)
        if (ChronoUnit.HOURS.between(lastInteraction, now) >= 2) {
            recommendations.add(
                Recommendation(
                    type = RecommendationType.HEALTH,
                    title = "喝水提醒",
                    content = "记得多喝水哦，对身体好",
                    priority = Priority.MEDIUM,
                    action = RecommendationAction.Notification
                )
            )
        }
        
        // 运动建议（根据天气和时间）
        if (hour in 8..10) {
            val weather = weatherService.getCurrentWeather()
            if (weather.isGoodForOutdoor()) {
                recommendations.add(
                    Recommendation(
                        type = RecommendationType.ACTIVITY,
                        title = "运动建议",
                        content = "今天天气不错，适合散步，出去走走吧",
                        priority = Priority.MEDIUM,
                        action = RecommendationAction.Notification
                    )
                )
            }
        }
        
        return recommendations
    }
    
    /**
     * 社交互动建议
     */
    private suspend fun suggestSocialInteractions(userId: Long): List<Recommendation> {
        val recommendations = mutableListOf<Recommendation>()
        
        // 检查子女互动
        val lastFamilyInteraction = userBehaviorService
            .getLastFamilyInteractionTime(userId)
        val hoursSinceLastContact = ChronoUnit.HOURS
            .between(lastFamilyInteraction, LocalDateTime.now())
        
        if (hoursSinceLastContact >= 24) {
            recommendations.add(
                Recommendation(
                    type = RecommendationType.SOCIAL,
                    title = "联系家人",
                    content = "很久没和孩子聊天了，打个电话吧",
                    priority = Priority.MEDIUM,
                    action = RecommendationAction.OpenPhone
                )
            )
        }
        
        // 检查未读留言
        val unreadCount = userBehaviorService.getUnreadMessageCount(userId)
        if (unreadCount > 0) {
            recommendations.add(
                Recommendation(
                    type = RecommendationType.MESSAGE,
                    title = "新留言",
                    content = "有${unreadCount}条新留言，快来听听吧",
                    priority = Priority.HIGH,
                    action = RecommendationAction.OpenMessages
                )
            )
        }
        
        return recommendations
    }
    
    /**
     * 安全警告
     */
    private suspend fun checkSecurityAlerts(userId: Long): List<Recommendation> {
        val recommendations = mutableListOf<Recommendation>()
        
        // 检查最近通话记录
        val recentCalls = userBehaviorService.getRecentCalls(userId, hours = 1)
        
        recentCalls.forEach { call ->
            if (call.isRisky) {
                recommendations.add(
                    Recommendation(
                        type = RecommendationType.SECURITY,
                        title = "安全警告",
                        content = "您刚接到一个可疑电话，请小心诈骗",
                        priority = Priority.CRITICAL,
                        action = RecommendationAction.ShowSecurityAlert(call.phoneNumber)
                    )
                )
            }
        }
        
        return recommendations
    }
}

// 推荐类型
enum class RecommendationType {
    MEDICINE,   // 药品
    HEALTH,     // 健康
    ACTIVITY,   // 活动
    SOCIAL,     // 社交
    MESSAGE,    // 消息
    SECURITY    // 安全
}

// 优先级
enum class Priority(val value: Int) {
    CRITICAL(4),  // 紧急
    HIGH(3),      // 高
    MEDIUM(2),    // 中
    LOW(1)        // 低
}

// 推荐行动
sealed class RecommendationAction {
    object Notification : RecommendationAction()
    data class OpenMedicine(val reminderId: Long) : RecommendationAction()
    object OpenPhone : RecommendationAction()
    object OpenMessages : RecommendationAction()
    data class ShowSecurityAlert(val phoneNumber: String) : RecommendationAction()
}

// 推荐模型
data class Recommendation(
    val type: RecommendationType,
    val title: String,
    val content: String,
    val priority: Priority,
    val action: RecommendationAction,
    val timestamp: LocalDateTime = LocalDateTime.now()
)
```

### 6.3 用户行为分析

```kotlin
// 用户行为分析服务
class UserBehaviorService(private val behaviorRepo: BehaviorRepository) {
    
    /**
     * 记录用户行为
     */
    suspend fun recordBehavior(
        userId: Long,
        action: UserAction,
        context: Map<String, Any> = emptyMap()
    ) {
        val behavior = UserBehavior(
            userId = userId,
            action = action,
            context = context,
            timestamp = LocalDateTime.now()
        )
        behaviorRepo.save(behavior)
        
        // 异步分析
        analyzePattern(userId, action)
    }
    
    /**
     * 分析用户习惯
     */
    private suspend fun analyzePattern(userId: Long, action: UserAction) {
        when (action) {
            UserAction.MEDICINE_CHECK -> {
                // 分析用药频率
                val frequency = calculateMedicineCheckFrequency(userId)
                if (frequency > 5) {  // 每天超过5次
                    // 可能需要添加提醒
                    suggestMedicineReminder(userId)
                }
            }
            UserAction.CALL_FAMILY -> {
                // 分析通话习惯
                val preferredTime = findPreferredCallTime(userId)
                // 在习惯时间提示打电话
            }
            else -> {}
        }
    }
    
    /**
     * 获取用户习惯画像
     */
    suspend fun getUserProfile(userId: Long): UserProfile {
        val recentBehaviors = behaviorRepo
            .findByUserIdAndTimestampAfter(
                userId,
                LocalDateTime.now().minusDays(30)
            )
        
        return UserProfile(
            userId = userId,
            mostActiveHours = calculateActiveHours(recentBehaviors),
            preferredFeatures = calculatePreferredFeatures(recentBehaviors),
            medicineCheckFrequency = calculateMedicineCheckFrequency(userId),
            socialInteractionLevel = calculateSocialLevel(recentBehaviors)
        )
    }
    
    private fun calculateActiveHours(behaviors: List<UserBehavior>): List<Int> {
        return behaviors
            .groupBy { it.timestamp.hour }
            .entries
            .sortedByDescending { it.value.size }
            .take(3)
            .map { it.key }
    }
    
    private fun calculatePreferredFeatures(behaviors: List<UserBehavior>): List<UserAction> {
        return behaviors
            .groupBy { it.action }
            .entries
            .sortedByDescending { it.value.size }
            .take(5)
            .map { it.key }
    }
}

// 用户行为
enum class UserAction {
    APP_OPEN,           // 打开APP
    MEDICINE_CHECK,     // 查药
    CALL_FAMILY,        // 打电话
    PLAY_MESSAGE,       // 听留言
    CHAT_WITH_AI,       // 与AI聊天
    TEXT_RECOGNITION    // 文字识别
}

// 用户画像
data class UserProfile(
    val userId: Long,
    val mostActiveHours: List<Int>,              // 活跃时段
    val preferredFeatures: List<UserAction>,     // 常用功能
    val medicineCheckFrequency: Int,             // 查药频率
    val socialInteractionLevel: InteractionLevel // 社交活跃度
)

enum class InteractionLevel {
    HIGH, MEDIUM, LOW
}
```

## 7. 第三方AI服务集成

### 7.1 API接口封装

#### 统一API客户端

```kotlin
// AI服务客户端封装
class AiServiceClient(
    private val httpClient: OkHttpClient,
    private val configManager: AiConfigManager
) {
    
    /**
     * 通用API调用
     */
    suspend fun <T> callApi(
        service: AiService,
        endpoint: String,
        request: Any,
        responseClass: Class<T>
    ): Result<T> {
        return withContext(Dispatchers.IO) {
            try {
                val config = configManager.getServiceConfig(service)
                val url = "${config.baseUrl}$endpoint"
                
                // 构建请求
                val httpRequest = Request.Builder()
                    .url(url)
                    .post(RequestBody.create(
                        "application/json".toMediaType(),
                        Json.encodeToString(request)
                    ))
                    .addHeader("Authorization", config.apiKey)
                    .addHeader("Content-Type", "application/json")
                    .build()
                
                // 执行请求
                val response = httpClient.newCall(httpRequest).execute()
                
                if (response.isSuccessful) {
                    val body = response.body?.string() ?: ""
                    val result = Json.decodeFromString<T>(responseClass, body)
                    Result.success(result)
                } else {
                    Result.failure(ApiException(response.code, response.message))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    /**
     * 流式API调用（SSE）
     */
    fun callStreamApi(
        service: AiService,
        endpoint: String,
        request: Any
    ): Flow<String> = flow {
        val config = configManager.getServiceConfig(service)
        val url = "${config.baseUrl}$endpoint"
        
        val httpRequest = Request.Builder()
            .url(url)
            .post(RequestBody.create(
                "application/json".toMediaType(),
                Json.encodeToString(request)
            ))
            .addHeader("Authorization", config.apiKey)
            .build()
        
        httpClient.newCall(httpRequest).execute().use { response ->
            val source = response.body?.source() ?: return@flow
            
            while (!source.exhausted()) {
                val line = source.readUtf8Line() ?: break
                if (line.startsWith("data: ")) {
                    emit(line.substring(6))
                }
            }
        }
    }
}

enum class AiService {
    XUNFEI_ASR,      // 讯飞语音识别
    XUNFEI_TTS,      // 讯飞语音合成
    ALIYUN_OCR,      // 阿里云OCR
    BAIDU_UNIT,      // 百度UNIT
    TONGYI_LLM       // 通义千问
}
```

### 7.2 服务配置管理

```kotlin
// AI服务配置
data class AiServiceConfig(
    val service: AiService,
    val baseUrl: String,
    val apiKey: String,
    val apiSecret: String? = null,
    val appId: String? = null,
    val timeout: Duration = Duration.ofSeconds(10),
    val maxRetries: Int = 3
)

// 配置管理器
class AiConfigManager(private val context: Context) {
    
    private val configs = mutableMapOf<AiService, AiServiceConfig>()
    
    init {
        loadConfigs()
    }
    
    private fun loadConfigs() {
        // 讯飞语音
        configs[AiService.XUNFEI_ASR] = AiServiceConfig(
            service = AiService.XUNFEI_ASR,
            baseUrl = "wss://iat-api.xfyun.cn/v2/iat",
            apiKey = BuildConfig.XUNFEI_API_KEY,
            apiSecret = BuildConfig.XUNFEI_API_SECRET,
            appId = BuildConfig.XUNFEI_APP_ID
        )
        
        configs[AiService.XUNFEI_TTS] = AiServiceConfig(
            service = AiService.XUNFEI_TTS,
            baseUrl = "wss://tts-api.xfyun.cn/v2/tts",
            apiKey = BuildConfig.XUNFEI_API_KEY,
            apiSecret = BuildConfig.XUNFEI_API_SECRET,
            appId = BuildConfig.XUNFEI_APP_ID
        )
        
        // 阿里云OCR
        configs[AiService.ALIYUN_OCR] = AiServiceConfig(
            service = AiService.ALIYUN_OCR,
            baseUrl = "https://ocr-api.cn-shanghai.aliyuncs.com",
            apiKey = BuildConfig.ALIYUN_ACCESS_KEY,
            apiSecret = BuildConfig.ALIYUN_ACCESS_SECRET
        )
        
        // 百度UNIT
        configs[AiService.BAIDU_UNIT] = AiServiceConfig(
            service = AiService.BAIDU_UNIT,
            baseUrl = "https://aip.baidubce.com/rpc/2.0/unit/service/v3/chat",
            apiKey = BuildConfig.BAIDU_API_KEY,
            apiSecret = BuildConfig.BAIDU_SECRET_KEY
        )
        
        // 通义千问
        configs[AiService.TONGYI_LLM] = AiServiceConfig(
            service = AiService.TONGYI_LLM,
            baseUrl = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation",
            apiKey = BuildConfig.TONGYI_API_KEY
        )
    }
    
    fun getServiceConfig(service: AiService): AiServiceConfig {
        return configs[service] 
            ?: throw IllegalArgumentException("Service $service not configured")
    }
}
```

### 7.3 错误处理与重试

```kotlin
// 重试策略
class RetryStrategy {
    
    companion object {
        /**
         * 指数退避重试
         */
        suspend fun <T> retryWithExponentialBackoff(
            maxRetries: Int = 3,
            initialDelay: Long = 1000,
            maxDelay: Long = 10000,
            factor: Double = 2.0,
            block: suspend () -> T
        ): T {
            var currentDelay = initialDelay
            repeat(maxRetries - 1) { attempt ->
                try {
                    return block()
                } catch (e: Exception) {
                    if (!shouldRetry(e)) {
                        throw e
                    }
                    
                    Log.w("RetryStrategy", "Attempt ${attempt + 1} failed", e)
                    delay(currentDelay)
                    currentDelay = (currentDelay * factor).toLong()
                        .coerceAtMost(maxDelay)
                }
            }
            return block()  // 最后一次尝试
        }
        
        private fun shouldRetry(e: Exception): Boolean {
            return when (e) {
                is SocketTimeoutException -> true
                is UnknownHostException -> true
                is ConnectException -> true
                is ApiException -> e.code in 500..599  // 服务器错误
                else -> false
            }
        }
    }
}

// API异常
class ApiException(val code: Int, message: String) : Exception(message)
```

### 7.4 降级策略

```kotlin
// AI服务降级管理器
class AiFallbackManager {
    
    /**
     * ASR降级：讯飞 -> 百度 -> 本地识别
     */
    suspend fun recognizeSpeechWithFallback(
        audioData: ByteArray
    ): String {
        // 主服务：讯飞ASR
        try {
            return AsrManager.recognize(audioData, AsrProvider.XUNFEI)
        } catch (e: Exception) {
            Log.w("Fallback", "Xunfei ASR failed, trying Baidu", e)
        }
        
        // 备用服务：百度ASR
        try {
            return AsrManager.recognize(audioData, AsrProvider.BAIDU)
        } catch (e: Exception) {
            Log.w("Fallback", "Baidu ASR failed, using local", e)
        }
        
        // 本地识别（离线）
        return LocalAsrEngine.recognize(audioData)
    }
    
    /**
     * TTS降级：讯飞 -> 系统 TTS
     */
    suspend fun synthesizeSpeechWithFallback(
        text: String
    ): ByteArray {
        // 主服务：讯飞TTS
        try {
            return TtsManager.synthesize(text, TtsProvider.XUNFEI)
        } catch (e: Exception) {
            Log.w("Fallback", "Xunfei TTS failed, using system TTS", e)
        }
        
        // 备用：Android系统 TTS
        return SystemTtsEngine.synthesize(text)
    }
    
    /**
     * OCR降级：阿里云 -> Google ML Kit
     */
    suspend fun recognizeTextWithFallback(
        imageData: ByteArray
    ): String {
        // 主服务：阿里云OCR
        try {
            return OcrService.recognize(imageData, OcrProvider.ALIYUN)
        } catch (e: Exception) {
            Log.w("Fallback", "Aliyun OCR failed, using ML Kit", e)
        }
        
        // 备用：Google ML Kit（本地）
        return MlKitOcr.recognize(imageData)
    }
    
    /**
     * NLU降级：百度UNIT -> 本地规则
     */
    suspend fun understandWithFallback(
        text: String,
        userId: Long
    ): NluResult {
        // 主服务：百度UNIT
        try {
            return BaiduUnitService.understand(text, userId)
        } catch (e: Exception) {
            Log.w("Fallback", "Baidu UNIT failed, using local rules", e)
        }
        
        // 备用：本地规则匹配
        return LocalNluEngine.understand(text)
    }
}
```

### 7.5 成本优化

```kotlin
// AI服务成本监控
class AiCostMonitor(
    private val redis: RedisTemplate<String, Any>
) {
    
    /**
     * 记录API调用成本
     */
    fun recordApiCall(
        service: AiService,
        callType: String,
        cost: Double
    ) {
        val key = "ai:cost:${LocalDate.now()}:${service.name}"
        redis.opsForHash<String, Double>().increment(key, callType, cost)
        
        // 设置过30天过期
        redis.expire(key, Duration.ofDays(30))
    }
    
    /**
     * 获取成本统计
     */
    fun getCostStatistics(
        service: AiService,
        startDate: LocalDate,
        endDate: LocalDate
    ): CostStatistics {
        var totalCost = 0.0
        val dailyCosts = mutableListOf<DailyCost>()
        
        var currentDate = startDate
        while (!currentDate.isAfter(endDate)) {
            val key = "ai:cost:$currentDate:${service.name}"
            val dayCost = redis.opsForHash<String, Double>()
                .entries(key)
                .values
                .sum()
            
            dailyCosts.add(DailyCost(currentDate, dayCost))
            totalCost += dayCost
            
            currentDate = currentDate.plusDays(1)
        }
        
        return CostStatistics(
            service = service,
            startDate = startDate,
            endDate = endDate,
            totalCost = totalCost,
            dailyCosts = dailyCosts,
            averageDailyCost = totalCost / dailyCosts.size
        )
    }
    
    /**
     * 成本预警
     */
    fun checkCostAlert(service: AiService): CostAlert? {
        val todayCost = getCostStatistics(
            service,
            LocalDate.now(),
            LocalDate.now()
        ).totalCost
        
        // 设置每日阈值
        val threshold = when (service) {
            AiService.XUNFEI_ASR -> 50.0   // ￥50/天
            AiService.XUNFEI_TTS -> 30.0   // ￥30/天
            AiService.ALIYUN_OCR -> 20.0   // ￥20/天
            AiService.BAIDU_UNIT -> 10.0   // ￥10/天
            AiService.TONGYI_LLM -> 100.0  // ￥100/天
        }
        
        return if (todayCost > threshold) {
            CostAlert(
                service = service,
                currentCost = todayCost,
                threshold = threshold,
                message = "${service.name}今日成本已超过阈值"
            )
        } else null
    }
}

data class CostStatistics(
    val service: AiService,
    val startDate: LocalDate,
    val endDate: LocalDate,
    val totalCost: Double,
    val dailyCosts: List<DailyCost>,
    val averageDailyCost: Double
)

data class DailyCost(
    val date: LocalDate,
    val cost: Double
)

data class CostAlert(
    val service: AiService,
    val currentCost: Double,
    val threshold: Double,
    val message: String
)
```

### 7.6 服务状态监控

```kotlin
// AI服务健康检查
class AiHealthChecker(
    private val serviceClient: AiServiceClient,
    private val alertService: AlertService
) {
    
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    /**
     * 定期健康检查
     */
    fun startHealthCheck() {
        scope.launch {
            while (true) {
                AiService.values().forEach { service ->
                    checkServiceHealth(service)
                }
                delay(Duration.ofMinutes(5).toMillis())
            }
        }
    }
    
    private suspend fun checkServiceHealth(service: AiService) {
        val startTime = System.currentTimeMillis()
        
        try {
            when (service) {
                AiService.XUNFEI_ASR -> {
                    // 检查ASR服务
                    // 发送测试请求...
                }
                // ... 其他服务
                else -> {}
            }
            
            val latency = System.currentTimeMillis() - startTime
            recordHealthStatus(service, true, latency)
            
        } catch (e: Exception) {
            recordHealthStatus(service, false, -1)
            alertService.sendAlert(
                "AI服务异常",
                "${service.name} 服务不可用: ${e.message}"
            )
        }
    }
    
    private fun recordHealthStatus(
        service: AiService,
        isHealthy: Boolean,
        latency: Long
    ) {
        // 记录到监控系统
        Log.d("HealthCheck", "$service: healthy=$isHealthy, latency=${latency}ms")
    }
}
```

---

## 总结

本文档详细设计了银龄守候系统的AI能力模块，涵盖：

1. **语音交互**：集成讯飞ASR/TTS，实现实时语音识别和合成
2. **图像识别**：基于阿里云OCR，实现药品识别和文字阅读
3. **自然语言理解**：使用百度UNIT进行意图识别和对话管理
4. **虚拟形象**：Lottie动画实现虚拟助手，支持口型同步
5. **智能推荐**：基于用户行为分析，个性化推荐服务
6. **第三方集成**：统一封装API调用，实现降级和成本控制

所有模块都遵循MVVM + Clean Architecture设计模式，确保代码可维护性和可扩展性。
